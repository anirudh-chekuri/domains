name: Trigger SQL Pipeline Update

on:
  push:
    branches: [ main ]
    paths:
      - 'domain_1/*.sql'

jobs:
  update-pipeline:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Load Configuration
      id: load_config
      run: |
        DOMAIN_ID=$(grep '^domainid=' domain_1/config.txt | cut -d '=' -f 2)
        HOST=$(grep '^host=' domain_1/config.txt | cut -d '=' -f 2)
        echo "DOMAIN_ID=${DOMAIN_ID}" >> $GITHUB_ENV
        echo "HOST=${HOST}" >> $GITHUB_ENV

    - name: Fetch Token
      id: fetch_token
      run: |
        TOKEN_RESPONSE=$(curl -k --silent --location "https://${{ env.HOST }}/v3/security/token/access" \
          --header "Authorization: Basic ${{ secrets.REFRESH_TOKEN }}" || { echo "Token fetch failed"; exit 1; })
        
        # Print the full response for debugging
        echo "Token API Response: $TOKEN_RESPONSE"
        
        # Extract the token
        TOKEN=$(echo $TOKEN_RESPONSE | jq -r '.result.authentication_token' || { echo "Token extraction failed"; exit 1; })
        echo "TOKEN=$TOKEN" >> $GITHUB_ENV

    - name: Determine Commit Range
      id: determine_commits
      run: |
        firstCommit='${{ github.event.before }}'
        lastCommit='${{ github.sha }}'
        echo "FIRST_COMMIT=${firstCommit}" >> $GITHUB_ENV
        echo "LAST_COMMIT=${lastCommit}" >> $GITHUB_ENV

    - name: Get the list of changed SQL files
      id: changed_files
      run: |
        git fetch origin
        changed_files=$(git diff --name-only --diff-filter=d "${FIRST_COMMIT}" "${LAST_COMMIT}" | grep '^domain_1/.*\.sql$' || true)
        echo "Changed files: $changed_files"
        echo "CHANGED_FILES=${changed_files}" >> $GITHUB_ENV

    - name: Fetch Pipeline IDs
      id: fetch_pipeline_ids
      run: |
        pipelines=$(curl -k --location "https://${{ env.HOST }}/v3/domains/${{ env.DOMAIN_ID }}/pipelines" \
          --header "Authorization: Bearer ${{ env.TOKEN }}" || { echo "Pipeline fetch failed"; exit 1; })
        echo "$pipelines" | jq -r '.result[] | "\(.name) \(.id)"' > pipelines.txt
        cat pipelines.txt
        for file in ${{ env.CHANGED_FILES }}; do
          base_filename=$(basename "$file")
          pipeline_name="${base_filename%.sql}"
          echo "Processing $pipeline_name"
          pipeline_id=$(grep -w "$pipeline_name" pipelines.txt | awk '{print $2}')
          if [ "$pipeline_id" != "null" ]; then
            echo "Pipeline ID for $pipeline_name is $pipeline_id"
            query=$(cat $file | base64 | tr -d '\n') # Ensure query is a single line
            payload="{\"pipeline_id\": \"$pipeline_id\", \"type\": \"sql\", \"query\": \"$query\"}"
            echo "Payload: $payload" # Print payload before sending

            create_response=$(curl -k --request POST \
              --url "https://${{ env.HOST }}/v3/domains/${{ env.DOMAIN_ID }}/pipelines/$pipeline_id/versions" \
              --header "Content-Type: application/json" \
              --header "Authorization: Bearer ${{ env.TOKEN }}" \
              --data "$payload" || { echo "Pipeline version creation failed"; exit 1; })
            echo $create_response
            
            pipeline_version_id=$(echo $create_response | jq -r '.result.id' || { echo "Version ID extraction failed"; exit 1; })
            
            curl -k --request POST \
              --url "https://${{ env.HOST }}/v3/domains/${{ env.DOMAIN_ID }}/pipelines/$pipeline_id/versions/$pipeline_version_id/set-active" \
              --header "Authorization: Bearer ${{ env.TOKEN }}" || { echo "Setting pipeline version active failed"; exit 1; }
          else
            echo "Pipeline ID not found for $pipeline_name"
          fi
        done
