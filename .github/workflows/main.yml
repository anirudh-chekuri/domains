name: Trigger SQL Pipeline Update

on:
  push:
    branches: [ main ]
    paths:
      - 'domain_1/*.sql'

jobs:
  update-pipeline:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Load Configuration
      id: load_config
      run: |
        DOMAIN_ID=$(grep '^domainid=' domain_1/config.txt | cut -d '=' -f 2)
        HOST=$(grep '^host=' domain_1/config.txt | cut -d '=' -f 2)
        ENVIRONMENT_ID=$(grep '^environmentid=' domain_1/config.txt | cut -d '=' -f 2)
        if [ -z "$DOMAIN_ID" ] || [ -z "$HOST" ] || [ -z "$ENVIRONMENT_ID" ]; then
          echo "Configuration values missing!"
          exit 1
        fi
        echo "DOMAIN_ID=${DOMAIN_ID}" >> $GITHUB_ENV
        echo "HOST=${HOST}" >> $GITHUB_ENV
        echo "ENVIRONMENT_ID=${ENVIRONMENT_ID}" >> $GITHUB_ENV

    - name: Fetch Token
      id: fetch_token
      run: |
        TOKEN_RESPONSE=$(curl -k --silent --location "https://${{ env.HOST }}/v3/security/token/access" \
          --header "Authorization: Basic ${{ secrets.REFRESH_TOKEN }}")
        
        # Print the full response for debugging
        echo "Token API Response: $TOKEN_RESPONSE"
        
        # Extract the token
        TOKEN=$(echo $TOKEN_RESPONSE | jq -r '.result.authentication_token')
        if [ -z "$TOKEN" ] || [ "$TOKEN" == "null" ]; then
          echo "Token extraction failed"
          exit 1
        fi
        echo "TOKEN=$TOKEN" >> $GITHUB_ENV

    - name: Determine Commit Range
      id: determine_commits
      run: |
        firstCommit='${{ github.event.before }}'
        lastCommit='${{ github.sha }}'
        if [ "$firstCommit" == "0000000000000000000000000000000000000000" ]; then
          firstCommit=$(git rev-list --max-parents=0 HEAD)
        fi
        echo "FIRST_COMMIT=${firstCommit}" >> $GITHUB_ENV
        echo "LAST_COMMIT=${lastCommit}" >> $GITHUB_ENV

    - name: Get the list of changed and new SQL files
      id: changed_files
      run: |
        git fetch origin
        # List of changed files
        changed_files=$(git diff --name-only --diff-filter=M "${FIRST_COMMIT}" "${LAST_COMMIT}" | grep '^domain_1/.*\.sql$' || true)
        echo "Changed files: $changed_files"
        echo "CHANGED_FILES=${changed_files}" >> $GITHUB_ENV
        
        # List of new files
        new_files=$(git diff --name-only --diff-filter=A "${FIRST_COMMIT}" "${LAST_COMMIT}" | grep '^domain_1/.*\.sql$' || true)
        if [ -n "$new_files" ]; then
          echo "New SQL files added in the recent push: $new_files"
        else
          echo "No new SQL files added."
        fi
        echo "NEW_FILES=${new_files}" >> $GITHUB_ENV

    - name: Fetch Pipeline IDs
      id: fetch_pipeline_ids
      run: |
        pipelines=$(curl -k --location "https://${{ env.HOST }}/v3/domains/${{ env.DOMAIN_ID }}/pipelines" \
          --header "Authorization: Bearer ${{ env.TOKEN }}")
        if [ -z "$pipelines" ]; then
          echo "Failed to fetch pipelines"
          exit 1
        fi
        echo "$pipelines" | jq -r '.result[] | "\(.name) \(.id)"' > pipelines.txt
        cat pipelines.txt

    - name: Create or Update Pipelines
      id: create_or_update_pipelines
      run: |
        for file in ${{ env.NEW_FILES }}; do
          base_filename=$(basename "$file")
          pipeline_name="${base_filename%.sql}"
          echo "Processing new pipeline $pipeline_name"
          
          pipeline_id=$(grep -w "$pipeline_name" pipelines.txt | awk '{print $2}')
          if [ -z "$pipeline_id" ]; then
            echo "Pipeline $pipeline_name not found. Creating a new pipeline."
            create_response=$(curl -k --request POST \
              --url "https://${{ env.HOST }}/v3/domains/${{ env.DOMAIN_ID }}/pipelines" \
              --header "Content-Type: application/json" \
              --header "Authorization: Bearer ${{ env.TOKEN }}" \
              --data "{\"name\": \"$pipeline_name\", \"domain_id\": \"${{ env.DOMAIN_ID }}\", \"environment_id\": \"${{ env.ENVIRONMENT_ID }}\", \"run_job_on_data_plane\": false}")

            if [ -z "$create_response" ]; then
              echo "Pipeline creation failed for $pipeline_name"
              exit 1
            fi
            echo "Pipeline creation response: $create_response"
            pipeline_id=$(echo $create_response | jq -r '.result.id')
            if [ -z "$pipeline_id" ] || [ "$pipeline_id" == "null" ]; then
              echo "Pipeline ID extraction failed for $pipeline_name"
              exit 1
            fi
          else
            echo "Pipeline $pipeline_name already exists with ID $pipeline_id. Skipping creation."
          fi

          query=$(cat $file | base64 | tr -d '\n') # Ensure query is a single line
          payload="{\"pipeline_id\": \"$pipeline_id\", \"type\": \"sql\", \"query\": \"$query\"}"
          echo "Payload: $payload" # Print payload before sending

          create_response=$(curl -k --request POST \
            --url "https://${{ env.HOST }}/v3/domains/${{ env.DOMAIN_ID }}/pipelines/$pipeline_id/versions" \
            --header "Content-Type: application/json" \
            --header "Authorization: Bearer ${{ env.TOKEN }}" \
            --data "$payload")
          if [ -z "$create_response" ]; then
            echo "Pipeline version creation failed for $pipeline_name"
            exit 1
          fi
          echo $create_response
          
          pipeline_version_id=$(echo $create_response | jq -r '.result.id')
          if [ -n "$pipeline_version_id" ] && [ "$pipeline_version_id" != "null" ]; then
            curl -k --request POST \
              --url "https://${{ env.HOST }}/v3/domains/${{ env.DOMAIN_ID }}/pipelines/$pipeline_id/versions/$pipeline_version_id/set-active" \
              --header "Authorization: Bearer ${{ env.TOKEN }}" || { echo "Setting pipeline version active failed"; exit 1; }
          else
            echo "Version ID extraction failed for $pipeline_name"
            exit 1
          fi
        done
