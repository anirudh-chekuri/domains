name: Trigger SQL Pipeline Update

on:
  push:
    paths:
      - 'domain_1/*.sql'

jobs:
  update-pipeline:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v2
      with:
        fetch-depth: 0

    - name: Check Git History
      run: git log --oneline

    - name: Load Configuration
      id: load_config
      run: |
        DOMAIN_ID=$(grep '^domainid=' domain_1/config.txt | cut -d '=' -f 2)
        HOST=$(grep '^host=' domain_1/config.txt | cut -d '=' -f 2)
        echo "DOMAIN_ID=${DOMAIN_ID}" >> $GITHUB_ENV
        echo "HOST=${HOST}" >> $GITHUB_ENV

    - name: Determine Changed SQL Files
      id: changed_files
      run: |
        # Fetch the latest changes
        git fetch origin
        
        # Check if there's a previous commit
        if git rev-parse --verify HEAD^ >/dev/null 2>&1; then
          # Get the list of changed SQL files
          changed_files=$(git diff --name-only HEAD^ HEAD | grep '^domain_1/.*\.sql$')

          # Initialize a variable to track existing SQL files
          existing_files=""

          for file in $changed_files; do
            # Check if the file exists in the previous commit
            if git ls-tree --name-only HEAD^ | grep -q "^${file}"; then
              existing_files+="${file} "
            fi
          done

          echo "EXISTING_CHANGED_FILES=${existing_files}" >> $GITHUB_ENV
        else
          echo "No previous commit found; setting EXISTING_CHANGED_FILES to empty."
          echo "EXISTING_CHANGED_FILES=" >> $GITHUB_ENV
        fi

    - name: Get Authentication Token
      id: get_token
      run: |
        TOKEN=$(curl -k --location "https://${{ env.HOST }}/v3/security/token/access" \
          --header "Authorization: Basic ${{ secrets.REFRESH_TOKEN }}" | jq -r '.result.authentication_token')
        echo "TOKEN=${TOKEN}" >> $GITHUB_ENV
      env:
        REFRESH_TOKEN: ${{ secrets.REFRESH_TOKEN }}

    - name: Get Pipeline IDs
      id: get_pipelines
      run: |
        response=$(curl -k --location "https://${{ env.HOST }}/v3/domains/${{ env.DOMAIN_ID }}/pipelines" \
          --header "Authorization: Bearer ${{ env.TOKEN }}")
        echo "API Response: $response"
        pipelines=$(echo $response | jq -r '.result[] | "\(.name)=\(.id)"')
        echo "PIPELINES=${pipelines}" >> $GITHUB_ENV

    - name: Create Pipeline Versions for Existing Files
      run: |
        for file in ${{ env.EXISTING_CHANGED_FILES }}; do
          name=$(basename "$file" .sql)
          pipeline_id=$(echo ${{ env.PIPELINES }} | grep "$name=" | cut -d '=' -f 2)
          query=$(base64 < "$file")
          
          # Create a new pipeline version
          response=$(curl -k --request POST \
            --url "https://${{ env.HOST }}/v3/domains/${{ env.DOMAIN_ID }}/pipelines/$pipeline_id/versions" \
            --header "Content-Type: application/json" \
            --header "Authorization: Bearer ${{ env.TOKEN }}" \
            --data "{\"pipeline_id\":\"$pipeline_id\",\"type\":\"sql\",\"query\":\"$query\"}")
          
          version_id=$(echo $response | jq -r '.result.id')
          echo "Created version $version_id for pipeline $name"

          # Set the newly created version as active
          curl -k --request POST \
            --url "https://${{ env.HOST }}/v3/domains/${{ env.DOMAIN_ID }}/pipelines/$pipeline_id/versions/$version_id/set-active" \
            --header "Authorization: Bearer ${{ env.TOKEN }}"
          echo "Set version $version_id as active for pipeline $name"
        done
