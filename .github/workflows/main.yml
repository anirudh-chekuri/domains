name: Trigger SQL Pipeline Update

on:
  push:
    paths:
      - 'domain_1/*.sql'

jobs:
  update-pipeline:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Load Configuration
      id: load_config
      run: |
        DOMAIN_ID=$(grep '^domainid=' domain_1/config.txt | cut -d '=' -f 2)
        HOST=$(grep '^host=' domain_1/config.txt | cut -d '=' -f 2)
        echo "DOMAIN_ID=${DOMAIN_ID}" >> $GITHUB_ENV
        echo "HOST=${HOST}" >> $GITHUB_ENV
        
    - name: Fetch token
      id: fetch_token
      run: |
        TOKEN_RESPONSE=$(curl -k --silent --location "https://${{ env.HOST }}/v3/security/token/access" \
          --header "Authorization: Basic ${{ secrets.REFRESH_TOKEN }}")
        
        # Print the full response for debugging
        echo "Token API Response: $TOKEN_RESPONSE"
        
        # Extract the token
        TOKEN=$(echo $TOKEN_RESPONSE | jq -r '.result.authentication_token')
        echo "TOKEN=$TOKEN" >> $GITHUB_ENV

    - name: Get the list of changed SQL files
      id: changed_files
      run: |
        git fetch origin
        git diff --name-only HEAD~1 > changed_files.txt
        
        echo "Changed files between HEAD~1 and HEAD:"
        cat changed_files.txt
        
        # Filter for SQL files directly under domain_1
        changed_files=$(grep '^domain_1/[^/]*\.sql$' changed_files.txt || true)
        echo "Filtered SQL files:"
        echo "$changed_files"
        
        # Initialize a variable to track existing SQL files
        existing_files=""
        
        for file in $changed_files; do
          # Check if the file exists in the previous commit
          if git ls-tree --name-only HEAD~1 | grep -q "^${file}"; then
            existing_files+="${file} "
          fi
        done
        
        echo "EXISTING_CHANGED_FILES=${existing_files}" >> $GITHUB_ENV

    - name: Fetch Pipeline IDs
      id: fetch_pipeline_ids
      run: |
        pipelines=$(curl -k --location "https://${{ env.HOST }}/v3/domains/${{ env.DOMAIN_ID }}/pipelines" \
          --header "Authorization: Bearer ${{ env.TOKEN }}" | jq -r '.result[] | {id: .id, name: .name}')
        echo "$pipelines" > pipelines.json
        echo $pipelines
        
    - name: Process Existing Changed Files
      if: ${{ env.EXISTING_CHANGED_FILES }}
      run: |
        for file in ${{ env.EXISTING_CHANGED_FILES }}; do
          pipeline_name=$(basename "$file" .sql)
          pipeline_id=$(jq -r --arg name "$pipeline_name" '.[] | select(.name == $name) | .id' pipelines.json)
          
          if [ "$pipeline_id" != "null" ]; then
            query=$(base64 < "$file")
            create_response=$(curl -k --request POST \
              --url "https://${{ env.HOST }}/v3/domains/${{ env.DOMAIN_ID }}/pipelines/$pipeline_id/versions" \
              --header "Content-Type: application/json" \
              --header "Authorization: Bearer ${{ env.TOKEN }}" \
              --data "{\"pipeline_id\": \"$pipeline_id\", \"type\": \"sql\", \"query\": \"$query\"}")
            
            pipeline_version_id=$(echo $create_response | jq -r '.result.id')
            
            curl -k --request POST \
              --url "https://${{ env.HOST }}/v3/domains/${{ env.DOMAIN_ID }}/pipelines/$pipeline_id/versions/$pipeline_version_id/set-active" \
              --header "Authorization: Bearer ${{ env.TOKEN }}"
          else
            echo "Pipeline ID not found for $pipeline_name"
          fi
        done
